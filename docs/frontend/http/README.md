## 前言

故事一定要从 `点击浏览器之后发生了什么` 开始说起


### HTTP 0.9

仅有 `GET` 一种方式。当时的需求很简单，就是用来传输体积很小的 `HTML` 文件

- 只有请求行，没有 `请求头`，`请求体`
- 同理，服务端只是返回数据。 没有 `响应头`, `响应体`

### HTTP 1.0

内容大大增加。增加了 `POST` 和 `HEAD` 命令，可以发送任何形式的内容。也规定了请求和相应格式。

### HTTP 1.1

- 长连接

默认使用长连接，长连接就是一次连接。连接期内多次发送请求。相比 `1.0` 每次请求都要进行 `TCP三次握手`, 节省大量时间。

长连接的请求时长可以再请求头的 `keep-alive` 中设置。

- 管线化

`1.0` 只有前一次请求发出并得到响应，第二次的请求才可以发出。

`1.1` 可以同时向服务器发出多个请求。但有 `队头阻塞` 的缺陷。

:::tip 队头阻塞
虽然一次发出多个请求，但是服务端响应还是按照请求顺序响应。

很可能出现：前面某个请求的响应时间很长，后面有很多请求排队等候。

很多厂子都做过管线化实验，由于种种原因，不得放弃。
- 支持断点续传，通过请求头的 `range`  来实现
- 新增缓存标识。`E-tag`、 `if-match`、 `if-none-match`
:::

:::warning 缺点
1. 队头阻塞
2. 请求头信息太多
3. 多次请求，请求头重复信息太多
4. 请求没有优先级
5. 只有客户端请求 - 服务端响应这个模式
:::


### HTTP 2.0

`2015`年发布，针对 `1.1` 有如下改变：

- 多路复用

每一个请求都对应一个 `id`，这样请求就可以分开。每个响应也都有对应 `id`，可以打包混合运送。客户端收到之后，根据自己id，将数据组合。

请求优先级，遇到高优先级的，可以停止当前相应，去处理优先级高的请求。

- 头部压缩

同时发送多个请求，头部会帮助消除重复的部分。这就是 `HPACK` 算法。

客户端、服务端同时维护一张头信息表，所有的字段都会存入这张表，生成索引号码，每一次仅仅发送索引号码就可以。这样网络传输更快。

- 二进制格式

`2.0` 不像 `1.1` 里纯文本形式的报文，而是全面采用二进制格式。虽然对人不友好，但是对于计算机，省去转化二级制的过程，增加了数据传输的效率。

- 数据流

`2.0` 不是按照顺序发送，同一个连接里面连续的数据包，可能属于不同的回应。

客户端发送的编号是奇数、服务端发出的编号是偶数。

客户端可以指定数据流的优先级，优先级高的请求，服务端就先响应其请求。

- 服务器推送

服务端可以主动向客户端发送消息

:::warning 缺点
1. 多个 `HTTP` 请求在复用一个 `TCP` 连接，而 `TCP` 协议是不知道有多少个 `HTTP` 请求。所以一旦发生丢包现象，就会触发 `TCP` 的 `重传机制`。这样一个 `TCP` 连接中的所有请求都必须等待这个丢失的包重新传回来。
:::


### HTTP 3.0